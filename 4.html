<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>ğŸ§¬ ç»†èƒè¿›åŒ–2 - è¶…çº§è¿›åŒ–</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            background: #0a0a1a;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        #gameCanvas {
            display: block;
            background: radial-gradient(circle at center, #1a1a2e 0%, #0a0a1a 100%);
        }

        /* HUD é¡¶éƒ¨çŠ¶æ€æ  */
        #hud {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 10px 15px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
            z-index: 100;
        }

        .hud-item {
            text-align: center;
            color: white;
        }

        .hud-value {
            font-size: 24px;
            font-weight: bold;
            color: #00ff88;
            text-shadow: 0 0 10px rgba(0,255,136,0.5);
        }

        .hud-label {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
            margin-top: 2px;
        }

        .hud-center {
            text-align: center;
        }

        .stage-badge {
            background: linear-gradient(135deg, #00ff88, #00ccff);
            color: #000;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            display: inline-block;
        }

        /* è™šæ‹Ÿæ‘‡æ† */
        #joystick-zone {
            position: fixed;
            bottom: 100px;
            left: 80px;
            width: 120px;
            height: 120px;
            z-index: 200;
        }

        #joystick-base {
            position: absolute;
            width: 100%;
            height: 100%;
            border: 3px solid rgba(255,255,255,0.2);
            border-radius: 50%;
            background: rgba(255,255,255,0.05);
        }

        #joystick-knob {
            position: absolute;
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #00ff88, #00ccff);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 20px rgba(0,255,136,0.5);
            transition: transform 0.1s;
        }

        #joystick-knob.active {
            transform: translate(-50%, -50%) scale(1.2);
        }

        /* æŠ€èƒ½æŒ‰é’® */
        #skill-panel {
            position: fixed;
            bottom: 100px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 200;
            max-height: 300px;
            overflow-y: auto;
        }

        .skill-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: 3px solid rgba(0,255,136,0.3);
            background: rgba(0,0,0,0.6);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 20px;
            position: relative;
            transition: all 0.2s;
            flex-shrink: 0;
        }

        .skill-btn:active {
            transform: scale(0.95);
            background: rgba(0,255,136,0.2);
        }

        .skill-btn.cooldown {
            opacity: 0.4;
            border-color: #444;
        }

        .skill-btn.active {
            border-color: #00ff88;
            box-shadow: 0 0 20px rgba(0,255,136,0.5);
            background: rgba(0,255,136,0.2);
        }

        .skill-btn.ready {
            animation: ready-pulse 1s infinite;
        }

        .skill-btn.super {
            border-color: #ff00ff;
            background: linear-gradient(135deg, rgba(255,0,255,0.2), rgba(128,0,128,0.3));
        }

        @keyframes ready-pulse {
            0%, 100% { box-shadow: 0 0 5px rgba(0,255,136,0.5); }
            50% { box-shadow: 0 0 20px rgba(0,255,136,0.8); }
        }

        .skill-name {
            font-size: 9px;
            margin-top: 2px;
            color: #aaa;
            text-align: center;
            line-height: 1.2;
        }

        .cooldown-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
        }

        /* è¿›åŒ–èœå•æŒ‰é’® */
        #evolution-btn {
            position: fixed;
            top: 80px;
            right: 15px;
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #ffaa00, #ff8800);
            border-radius: 50%;
            border: none;
            color: #000;
            font-size: 24px;
            font-weight: bold;
            z-index: 200;
            box-shadow: 0 4px 15px rgba(255,170,0,0.4);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #evolution-btn.pulse {
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        #evolution-btn .badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background: #ff0000;
            color: white;
            font-size: 12px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* è¿›åŒ–é¢æ¿ */
        #evolution-panel {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.95);
            z-index: 1000;
            display: none;
            flex-direction: column;
            padding: 20px;
            overflow: hidden;
            touch-action: none;
        }

        #evolution-panel.show {
            display: flex;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(0,255,136,0.3);
            flex-shrink: 0;
        }

        .panel-title {
            color: #00ff88;
            font-size: 24px;
            font-weight: bold;
        }

        .close-btn {
            width: 40px;
            height: 40px;
            background: rgba(255,255,255,0.1);
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .dna-display {
            text-align: center;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(0,255,136,0.1);
            border-radius: 15px;
            border: 1px solid rgba(0,255,136,0.3);
            flex-shrink: 0;
        }

        .dna-value {
            font-size: 32px;
            color: #00ff88;
            font-weight: bold;
        }

        .evolution-scroll-container {
            flex: 1;
            overflow: hidden;
            position: relative;
            touch-action: none;
        }

        .evolution-scroll-content {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding-bottom: 20px;
            transform: translateY(0);
            will-change: transform;
        }

        .evolution-list {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .evolution-card {
            background: rgba(255,255,255,0.05);
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 15px;
            text-align: center;
            transition: all 0.3s;
            touch-action: manipulation;
        }

        .evolution-card.available {
            border-color: #00ff88;
            background: rgba(0,255,136,0.1);
        }

        .evolution-card.unlocked {
            border-color: #00ff88;
            background: rgba(0,255,136,0.2);
            opacity: 0.8;
        }

        .evolution-card.locked {
            opacity: 0.4;
        }

        .evolution-card.super {
            border-color: #ff00ff;
            background: linear-gradient(135deg, rgba(255,0,255,0.1), rgba(128,0,128,0.2));
        }

        .evo-icon {
            font-size: 40px;
            margin-bottom: 10px;
        }

        .evo-name {
            color: #00ff88;
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 5px;
        }

        .evo-desc {
            font-size: 11px;
            color: #aaa;
            margin-bottom: 10px;
            line-height: 1.4;
        }

        .evo-cost {
            background: rgba(255,170,0,0.2);
            color: #ffaa00;
            padding: 5px 10px;
            border-radius: 10px;
            font-size: 12px;
            font-weight: bold;
            display: inline-block;
        }

        .evo-cost.paid {
            background: rgba(0,255,136,0.3);
            color: #00ff88;
        }

        .evo-status {
            font-size: 10px;
            margin-top: 5px;
            padding: 2px 6px;
            border-radius: 5px;
            display: inline-block;
        }

        .evo-status.ready {
            background: rgba(0,255,136,0.3);
            color: #00ff88;
        }

        .evo-status.used {
            background: rgba(255,0,0,0.3);
            color: #ff4444;
        }

        .scroll-hint {
            text-align: center;
            color: #666;
            font-size: 12px;
            padding: 10px;
            margin-top: 10px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        /* é€šçŸ¥ */
        #notification {
            position: fixed;
            top: 100px;
            left: 50%;
            transform: translateX(-50%) translateY(-100px);
            background: linear-gradient(135deg, #00ff88, #00ccff);
            color: #000;
            padding: 15px 30px;
            border-radius: 25px;
            font-weight: bold;
            font-size: 16px;
            opacity: 0;
            transition: all 0.3s;
            z-index: 500;
            pointer-events: none;
            box-shadow: 0 4px 20px rgba(0,255,136,0.4);
        }

        #notification.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        /* å¼€å§‹ç•Œé¢ */
        #start-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 30px;
        }

        .game-title {
            font-size: 48px;
            font-weight: bold;
            background: linear-gradient(135deg, #00ff88, #00ccff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 5px;
            text-align: center;
        }

        .author-credit {
            color: #666;
            font-size: 12px;
            margin-bottom: 30px;
            text-align: center;
            font-style: italic;
        }

        .game-subtitle {
            color: #888;
            margin-bottom: 20px;
            text-align: center;
        }

        .start-btn {
            background: linear-gradient(135deg, #00ff88, #00ccff);
            border: none;
            color: #000;
            padding: 20px 60px;
            border-radius: 30px;
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 20px;
            box-shadow: 0 4px 20px rgba(0,255,136,0.4);
        }

        .tutorial {
            color: #aaa;
            font-size: 14px;
            text-align: center;
            line-height: 1.6;
            max-width: 300px;
            margin-bottom: 20px;
        }

        .tutorial-item {
            margin: 10px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* æ›´æ–°æ—¥å¿—æŒ‰é’® */
        .changelog-btn {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(0,255,136,0.3);
            color: #00ff88;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            cursor: pointer;
            margin-bottom: 20px;
        }

        /* æ›´æ–°æ—¥å¿—é¢æ¿ */
        #changelog-panel {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.95);
            z-index: 2500;
            display: none;
            flex-direction: column;
            padding: 20px;
            overflow: hidden;
        }

        #changelog-panel.show {
            display: flex;
        }

        .changelog-content {
            flex: 1;
            overflow-y: auto;
            background: rgba(255,255,255,0.05);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            line-height: 1.6;
        }

        .changelog-content h3 {
            color: #00ff88;
            margin: 15px 0 10px 0;
            border-bottom: 1px solid rgba(0,255,136,0.3);
            padding-bottom: 5px;
        }

        .changelog-content ul {
            color: #aaa;
            padding-left: 20px;
        }

        .changelog-content li {
            margin: 8px 0;
        }

        .version-tag {
            background: linear-gradient(135deg, #00ff88, #00ccff);
            color: #000;
            padding: 5px 15px;
            border-radius: 15px;
            font-size: 14px;
            font-weight: bold;
            display: inline-block;
            margin-bottom: 10px;
        }

        .hidden {
            display: none !important;
        }

        /* æ­»äº¡ç•Œé¢ */
        #death-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.95);
            z-index: 3000;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 30px;
        }

        #death-screen.show {
            display: flex;
        }

        .death-icon {
            font-size: 80px;
            margin-bottom: 20px;
            animation: fadeIn 0.5s;
        }

        .death-title {
            font-size: 36px;
            color: #ff4444;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(255,68,68,0.5);
        }

        .death-stats {
            background: rgba(255,255,255,0.05);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            width: 100%;
            max-width: 300px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            color: #aaa;
            font-size: 16px;
        }

        .stat-value {
            color: #00ff88;
            font-weight: bold;
        }

        .respawn-btn {
            background: linear-gradient(135deg, #00ff88, #00ccff);
            border: none;
            color: #000;
            padding: 20px 60px;
            border-radius: 30px;
            font-size: 20px;
            font-weight: bold;
            margin-top: 20px;
            box-shadow: 0 4px 20px rgba(0,255,136,0.4);
            animation: pulse 2s infinite;
        }

        /* èƒœåˆ©ç•Œé¢ */
        #victory-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #1a0033, #330066, #1a0033);
            z-index: 4000;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 30px;
        }

        #victory-screen.show {
            display: flex;
        }

        .victory-icon {
            font-size: 100px;
            margin-bottom: 20px;
            animation: victory-bounce 2s infinite;
        }

        @keyframes victory-bounce {
            0%, 100% { transform: scale(1) rotate(0deg); }
            50% { transform: scale(1.2) rotate(10deg); }
        }

        .victory-title {
            font-size: 42px;
            background: linear-gradient(135deg, #ff00ff, #00ffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: bold;
            margin-bottom: 10px;
            text-align: center;
        }

        .victory-subtitle {
            color: #aaa;
            font-size: 18px;
            margin-bottom: 30px;
            text-align: center;
        }

        .victory-stats {
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 25px;
            margin: 20px 0;
            width: 100%;
            max-width: 320px;
            border: 2px solid rgba(255,0,255,0.3);
        }

        .victory-btn-group {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }

        .victory-btn {
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            border: none;
            cursor: pointer;
        }

        .victory-btn.continue {
            background: linear-gradient(135deg, #00ff88, #00ccff);
            color: #000;
        }

        .victory-btn.end {
            background: rgba(255,255,255,0.1);
            color: #fff;
            border: 2px solid rgba(255,0,255,0.5);
        }

        /* å°åœ°å›¾ */
        #minimap {
            position: fixed;
            top: 80px;
            left: 15px;
            width: 100px;
            height: 100px;
            background: rgba(0,0,0,0.6);
            border: 2px solid rgba(0,255,136,0.3);
            border-radius: 50%;
            overflow: hidden;
            z-index: 100;
        }

        #minimap-canvas {
            width: 100%;
            height: 100%;
        }

        /* åº•éƒ¨è¿›åº¦æ¡ */
        #progress-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: rgba(255,255,255,0.1);
            z-index: 300;
        }

        #progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #00ccff);
            width: 0%;
            transition: width 0.3s;
        }

        /* è§†é‡æŒ‡ç¤ºå™¨ */
        #view-indicator {
            position: fixed;
            top: 140px;
            right: 15px;
            background: rgba(0,0,0,0.6);
            border: 1px solid rgba(0,255,136,0.3);
            border-radius: 10px;
            padding: 8px 12px;
            color: #00ff88;
            font-size: 12px;
            z-index: 100;
        }

        /* å‡æ­»çŠ¶æ€æç¤º */
        #feign-death-indicator {
            position: fixed;
            top: 180px;
            right: 15px;
            background: rgba(128,0,128,0.6);
            border: 1px solid rgba(255,0,255,0.5);
            border-radius: 10px;
            padding: 8px 12px;
            color: #ff00ff;
            font-size: 12px;
            z-index: 100;
            display: none;
        }

        #feign-death-indicator.active {
            display: block;
        }

        /* æ¦‚ç‡äº‘å°±ç»ªæç¤º */
        #quantum-ready {
            position: fixed;
            top: 220px;
            right: 15px;
            background: rgba(0,100,255,0.6);
            border: 1px solid rgba(0,200,255,0.5);
            border-radius: 10px;
            padding: 8px 12px;
            color: #00ccff;
            font-size: 12px;
            z-index: 100;
            display: none;
        }

        #quantum-ready.active {
            display: block;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* è¶…çº§æŠ€èƒ½æ¿€æ´»æç¤º */
        #super-mode-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: bold;
            color: #ff00ff;
            text-shadow: 0 0 30px rgba(255,0,255,0.8);
            opacity: 0;
            pointer-events: none;
            z-index: 400;
            transition: opacity 0.5s;
        }

        #super-mode-indicator.active {
            opacity: 1;
            animation: super-pulse 0.5s infinite;
        }

        @keyframes super-pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
        }

        /* ç”Ÿå‘½å€¼è­¦å‘Š */
        #health-warning {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff0000;
            font-size: 48px;
            font-weight: bold;
            text-shadow: 0 0 20px rgba(255,0,0,0.8);
            opacity: 0;
            pointer-events: none;
            z-index: 400;
            transition: opacity 0.3s;
        }

        #health-warning.show {
            opacity: 1;
            animation: heartbeat 1s infinite;
        }

        @keyframes heartbeat {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.5); }
            to { opacity: 1; transform: scale(1); }
        }

        /* æ¿€å…‰æ•ˆæœ */
        .laser-beam {
            position: absolute;
            height: 4px;
            background: linear-gradient(90deg, transparent, #ff0000, #ffff00, #ff0000, transparent);
            box-shadow: 0 0 20px #ff0000;
            transform-origin: left center;
            pointer-events: none;
            z-index: 50;
        }

        /* ä½œè€…æ°´å° */
        .author-watermark {
            position: fixed;
            color: rgba(255,255,255,0.15);
            font-size: 12px;
            pointer-events: none;
            z-index: 10000;
            text-shadow: 0 0 5px rgba(0,0,0,0.5);
        }

        .watermark-tl { top: 10px; left: 10px; }
        .watermark-tr { top: 10px; right: 10px; }
        .watermark-bl { bottom: 10px; left: 10px; }
        .watermark-br { bottom: 10px; right: 10px; }
        .watermark-bottom { bottom: 5px; left: 50%; transform: translateX(-50%); }

        /* å…‘æ¢ç é¢æ¿ */
        #redeem-panel {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.95);
            z-index: 2600;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        #redeem-panel.show {
            display: flex;
        }

        .redeem-title {
            color: #00ff88;
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 20px;
        }

        .redeem-input {
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(0,255,136,0.3);
            color: white;
            padding: 15px;
            border-radius: 10px;
            font-size: 16px;
            width: 80%;
            max-width: 300px;
            margin-bottom: 20px;
            text-align: center;
        }

        .redeem-btn {
            background: linear-gradient(135deg, #00ff88, #00ccff);
            border: none;
            color: #000;
            padding: 15px 40px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .redeem-close {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 10px 30px;
            border-radius: 20px;
            font-size: 14px;
        }

        .redeem-hint {
            color: #888;
            font-size: 12px;
            margin-top: 15px;
            text-align: center;
        }

        /* å…‘æ¢ç æŒ‰é’® */
        #redeem-btn {
            position: fixed;
            top: 140px;
            right: 15px;
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #00ff88, #00ccff);
            border-radius: 50%;
            border: none;
            color: #000;
            font-size: 20px;
            font-weight: bold;
            z-index: 200;
            box-shadow: 0 4px 15px rgba(0,255,136,0.4);
            display: flex;
            align-items: center;
            justify-content: center;
        }
    </style>
</head>
<body>
    <!-- æ¸¸æˆç”»å¸ƒ -->
    <canvas id="gameCanvas"></canvas>
    
    <!-- å°åœ°å›¾ -->
    <div id="minimap">
        <canvas id="minimap-canvas"></canvas>
    </div>
    
    <!-- çŠ¶æ€æŒ‡ç¤ºå™¨ -->
    <div id="view-indicator">è§†é‡: <span id="view-range">100%</span></div>
    <div id="feign-death-indicator">ğŸ’€ å‡æ­»å°±ç»ª</div>
    <div id="quantum-ready">âš›ï¸ æ¦‚ç‡äº‘å°±ç»ª</div>
    <div id="super-mode-indicator">ğŸ”¥ è¶…çº§æ¨¡å¼</div>
    
    <!-- å…‘æ¢ç æŒ‰é’® -->
    <button id="redeem-btn" onclick="showRedeemPanel()">ğŸ</button>
    
    <!-- HUD -->
    <div id="hud">
        <div class="hud-item">
            <div class="hud-value" id="massDisplay">10</div>
            <div class="hud-label">è´¨é‡</div>
        </div>
        <div class="hud-center">
            <div class="stage-badge" id="stageDisplay">åŸå§‹ç»†èƒ</div>
        </div>
        <div class="hud-item">
            <div class="hud-value" id="dnaDisplay">0</div>
            <div class="hud-label">DNA</div>
        </div>
    </div>
    
    <!-- è¿›åº¦æ¡ -->
    <div id="progress-bar">
        <div id="progress-fill"></div>
    </div>
    
    <!-- è™šæ‹Ÿæ‘‡æ† -->
    <div id="joystick-zone">
        <div id="joystick-base"></div>
        <div id="joystick-knob"></div>
    </div>
    
    <!-- æŠ€èƒ½æŒ‰é’® -->
    <div id="skill-panel">
        <div class="skill-btn" id="skill-boost" data-skill="boost">
            âš¡
            <span class="skill-name">åŠ é€Ÿ</span>
            <div class="cooldown-overlay hidden" id="cd-boost">0</div>
        </div>
        <div class="skill-btn" id="skill-split" data-skill="split">
            ğŸ”„
            <span class="skill-name">åˆ†è£‚</span>
            <div class="cooldown-overlay hidden" id="cd-split">0</div>
        </div>
        <div class="skill-btn" id="skill-shield" data-skill="shield">
            ğŸ›¡ï¸
            <span class="skill-name">æŠ¤ç›¾</span>
            <div class="cooldown-overlay hidden" id="cd-shield">0</div>
        </div>
        <div class="skill-btn hidden" id="skill-quantum" data-skill="quantum">
            âš›ï¸
            <span class="skill-name">ç¬ç§»</span>
            <div class="cooldown-overlay hidden" id="cd-quantum">0</div>
        </div>
        <!-- è¶…çº§æŠ€èƒ½ -->
        <div class="skill-btn hidden super" id="skill-laser" data-skill="laser">
            ğŸ”¥
            <span class="skill-name">æ¯ç­<br>æ¿€å…‰</span>
            <div class="cooldown-overlay hidden" id="cd-laser">0</div>
        </div>
        <div class="skill-btn hidden super" id="skill-devour" data-skill="devour">
            ğŸŒŒ
            <span class="skill-name">å…¨å›¾<br>åå™¬</span>
            <div class="cooldown-overlay hidden" id="cd-devour">0</div>
        </div>
        <div class="skill-btn hidden super" id="skill-supercell" data-skill="supercell">
            ğŸ¦¸
            <span class="skill-name">è¶…çº§<br>ç»†èƒ</span>
            <div class="cooldown-overlay hidden" id="cd-supercell">0</div>
        </div>
        <div class="skill-btn hidden super" id="skill-insta" data-skill="instakill">
            ğŸ’€
            <span class="skill-name">ç§’æ€<br>ä¸€åˆ‡</span>
            <div class="cooldown-overlay hidden" id="cd-insta">0</div>
        </div>
        <div class="skill-btn hidden super" id="skill-track" data-skill="track">
            ğŸ¯
            <span class="skill-name">æ°”æ¯<br>è¿½è¸ª</span>
            <div class="cooldown-overlay hidden" id="cd-track">0</div>
        </div>
    </div>
    
    <!-- è¿›åŒ–èœå•æŒ‰é’® -->
    <button id="evolution-btn">
        ğŸ§¬
        <span class="badge hidden" id="evo-badge">!</span>
    </button>
    
    <!-- è¿›åŒ–é¢æ¿ -->
    <div id="evolution-panel">
        <!-- æ°´å° -->
        <div class="author-watermark watermark-tl">åŸåˆ›ä½œè€…:STN Studio</div>
        <div class="author-watermark watermark-tr">åŸåˆ›ä½œè€…:STN Studio</div>
        <div class="author-watermark watermark-bl">åŸåˆ›ä½œè€…:STN Studio</div>
        <div class="author-watermark watermark-br">åŸåˆ›ä½œè€…:STN Studio</div>
        <div class="author-watermark watermark-bottom">åŸåˆ›ä½œè€…:STN Studio</div>
        
        <div class="panel-header">
            <div class="panel-title">è¿›åŒ–æ ‘</div>
            <button class="close-btn" onclick="closeEvolution()">Ã—</button>
        </div>
        <div class="dna-display">
            <div class="dna-value" id="panel-dna">0 DNA</div>
            <div style="color: #888; font-size: 12px; margin-top: 5px;">å¯ç”¨ç‚¹æ•°</div>
        </div>
        
        <div class="evolution-scroll-container" id="scroll-container">
            <div class="evolution-scroll-content" id="scroll-content">
                <div class="evolution-list" id="evolution-list"></div>
                <div class="scroll-hint">ğŸ‘† åŒæŒ‡ä¸Šä¸‹æ»‘åŠ¨æŸ¥çœ‹æ›´å¤š</div>
            </div>
        </div>
    </div>
    
    <!-- å…‘æ¢ç é¢æ¿ -->
    <div id="redeem-panel">
        <div class="redeem-title">å…‘æ¢ç </div>
        <input type="text" class="redeem-input" id="redeem-input" placeholder="è¯·è¾“å…¥å…‘æ¢ç ">
        <button class="redeem-btn" onclick="redeemCode()">å…‘æ¢</button>
        <button class="redeem-close" onclick="closeRedeemPanel()">å…³é—­</button>
    </div>
    
    <!-- é€šçŸ¥ -->
    <div id="notification"></div>
    
    <!-- ç”Ÿå‘½å€¼è­¦å‘Š -->
    <div id="health-warning">âš ï¸ å±é™©</div>
    
    <!-- å¼€å§‹ç•Œé¢ -->
    <div id="start-screen">
        <div class="game-title">ğŸ§¬ ç»†èƒè¿›åŒ–2</div>
        <div class="author-credit">åŸåˆ›ä½œè€…:STN Studio</div>
        <div class="game-subtitle">è¶…çº§è¿›åŒ– Â· ç»ˆæåŠ›é‡</div>
        <button class="start-btn" onclick="startGame()">å¼€å§‹æ¸¸æˆ</button>
        <div class="tutorial">
            <div class="tutorial-item">ğŸ”¥ æ¯ç­æ¿€å…‰ï¼šæ‘§æ¯ç›´çº¿æ•Œäºº</div>
            <div class="tutorial-item">ğŸŒŒ å…¨å›¾åå™¬ï¼šåå™¬å…¨å›¾å°ç»†èƒ</div>
            <div class="tutorial-item">ğŸ¦¸ è¶…çº§ç»†èƒï¼š20ç§’æ— æ•Œå¼ºåŒ–</div>
            <div class="tutorial-item">ğŸ’€ ç§’æ€ä¸€åˆ‡ï¼šå¼•åŠ›èŒƒå›´ç§’æ€</div>
            <div class="tutorial-item">ğŸ¯ æ°”æ¯è¿½è¸ªï¼šè‡ªåŠ¨ç‹©çŒå°ç»†èƒ</div>
        </div>
        <button class="changelog-btn" onclick="showChangelog()">ğŸ“œ æ›´æ–°æ—¥å¿—</button>
    </div>
    
    <!-- æ›´æ–°æ—¥å¿—é¢æ¿ -->
    <div id="changelog-panel">
        <div class="panel-header">
            <div class="panel-title">ğŸ“œ æ›´æ–°æ—¥å¿—</div>
            <button class="close-btn" onclick="closeChangelog()">Ã—</button>
        </div>
        <div class="changelog-content" id="changelog-content"></div>
        <div class="author-watermark watermark-bottom">åŸåˆ›ä½œè€…:STN Studio</div>
        <button class="start-btn" onclick="closeChangelog()">å…³é—­</button>
    </div>
    
    <!-- æ­»äº¡ç•Œé¢ -->
    <div id="death-screen">
        <div class="death-icon">ğŸ’€</div>
        <div class="death-title">ç»†èƒæ­»äº¡</div>
        <div style="color: #888; margin-bottom: 20px;">ä½ çš„ç»†èƒè¢«åå™¬äº†</div>
        <div class="death-stats">
            <div class="stat-row">
                <span>æœ€ç»ˆè´¨é‡</span>
                <span class="stat-value" id="final-mass">0</span>
            </div>
            <div class="stat-row">
                <span>æ”¶é›†DNA</span>
                <span class="stat-value" id="final-dna">0</span>
            </div>
            <div class="stat-row">
                <span>ç”Ÿå­˜æ—¶é—´</span>
                <span class="stat-value" id="final-time">0s</span>
            </div>
            <div class="stat-row">
                <span>åå™¬æ•Œäºº</span>
                <span class="stat-value" id="final-kills">0</span>
            </div>
        </div>
        <div class="author-watermark watermark-bottom">åŸåˆ›ä½œè€…:STN Studio</div>
        <button class="respawn-btn" onclick="respawn()">ğŸ”„ é‡ç”Ÿ</button>
    </div>
    
    <!-- èƒœåˆ©ç•Œé¢ -->
    <div id="victory-screen">
        <div class="victory-icon">ğŸ‘‘</div>
        <div class="victory-title">è¿›åŒ–æˆåŠŸï¼</div>
        <div class="victory-subtitle">ä½ å·²è¾¾åˆ°æ™ºæ…§ç”Ÿå‘½é˜¶æ®µ</div>
        <div class="victory-stats">
            <div class="stat-row">
                <span>æœ€ç»ˆè´¨é‡</span>
                <span class="stat-value" id="victory-mass">0</span>
            </div>
            <div class="stat-row">
                <span>æ”¶é›†DNA</span>
                <span class="stat-value" id="victory-dna">0</span>
            </div>
            <div class="stat-row">
                <span>ç”Ÿå­˜æ—¶é—´</span>
                <span class="stat-value" id="victory-time">0s</span>
            </div>
            <div class="stat-row">
                <span>åå™¬æ•Œäºº</span>
                <span class="stat-value" id="victory-kills">0</span>
            </div>
        </div>
        <div class="author-watermark watermark-bottom">åŸåˆ›ä½œè€…:STN Studio</div>
        <div class="victory-btn-group">
            <button class="victory-btn continue" onclick="continueGame()">ç»§ç»­æ¸¸ç©</button>
            <button class="victory-btn end" onclick="endGame()">ç»“æŸæ¸¸æˆ</button>
        </div>
    </div>

    <script>
        // æ›´æ–°æ—¥å¿—å†…å®¹
        const changelogHTML = `
            <div class="version-tag">v2.3 - èŒç‹è¡€ç»Ÿ</div>
            <h3>ğŸ†• æ–°å¢è¿›åŒ–ï¼šèŒç‹è¡€ç»Ÿ</h3>
            <ul>
                <li><strong>èŒç‹è¡€ç»Ÿ</strong> - åœ¨è‡ªå·±å¼•åŠ›èŒƒå›´å†…æ‰€æœ‰ç»†èƒä¼šè¢«å®šä½ï¼ˆé™¤è‡ªå·±ï¼‰ï¼Œæ— æ³•ç§»åŠ¨</li>
            </ul>
            
            <h3>ğŸ”„ å…¶ä»–æ›´æ–°</h3>
            <ul>
                <li>å–æ¶ˆå…‘æ¢ç æç¤ºæ–‡å­—</li>
                <li>ä¼˜åŒ–æ¸¸æˆæ€§èƒ½</li>
            </ul>
            
            <div class="version-tag" style="margin-top: 20px;">v2.2 - ä½œè€…ç½²åä¸å…‘æ¢ç </div>
            <h3>ğŸ†• æ–°å¢å…‘æ¢ç ç³»ç»Ÿ</h3>
            <ul>
                <li>å…‘æ¢ç : ï¼Ÿï¼Ÿ</li>
                <li>æ¯ä¸ªå…‘æ¢ç å¯å…‘æ¢ä¸æ˜DNA</li>
            </ul>
            
            <h3>âœ¨ ä½œè€…ç½²å</h3>
            <ul>
                <li>æ¸¸æˆèƒœåˆ©é¡µé¢æ ‡æ³¨"åŸåˆ›ä½œè€…:STN Studio"</li>
                <li>å¼€å§‹æ¸¸æˆæ—¶å¼¹å‡ºä½œè€…æç¤º</li>
                <li>è¿›åŒ–é¡µé¢äº”å¤„æ°´å°ç½²å</li>
                <li>æ›´æ–°æ—¥å¿—åº•éƒ¨ç½²å</li>
                <li>æ­»äº¡é¡µé¢ç½²å</li>
            </ul>
            
            <div class="version-tag" style="margin-top: 20px;">v1.0 - åˆå§‹ç‰ˆæœ¬</div>
            <h3>ğŸ® åŸºç¡€åŠŸèƒ½</h3>
            <ul>
                <li>ç»†èƒè¿›åŒ–ç³»ç»Ÿ</li>
                <li>é‡åŠ›å¸å¼•æœºåˆ¶</li>
                <li>åŠ¨æ€è§†é‡ç¼©æ”¾</li>
                <li>æŠ€èƒ½ç³»ç»Ÿ</li>
            </ul>
        `;

        // å…‘æ¢ç ç³»ç»Ÿ
        const redeemCodes = {
            'LX520': 520,
            'STN666': 200
        };
        
        let usedCodes = new Set();

        function showRedeemPanel() {
            document.getElementById('redeem-panel').classList.add('show');
        }

        function closeRedeemPanel() {
            document.getElementById('redeem-panel').classList.remove('show');
            document.getElementById('redeem-input').value = '';
        }

        function redeemCode() {
            const code = document.getElementById('redeem-input').value.trim();
            
            if (!code) {
                showNotification('è¯·è¾“å…¥å…‘æ¢ç ï¼');
                return;
            }
            
            if (usedCodes.has(code)) {
                showNotification('è¯¥å…‘æ¢ç å·²ä½¿ç”¨ï¼');
                return;
            }
            
            if (redeemCodes[code]) {
                game.dna += redeemCodes[code];
                usedCodes.add(code);
                showNotification(`å…‘æ¢æˆåŠŸï¼è·å¾— ${redeemCodes[code]} DNAï¼`);
                closeRedeemPanel();
                updateEvolutionUI();
            } else {
                showNotification('å…‘æ¢ç æ— æ•ˆï¼');
            }
        }

        // ç”»å¸ƒè®¾ç½®
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const minimapCanvas = document.getElementById('minimap-canvas');
        const minimapCtx = minimapCanvas.getContext('2d');

        // æ¸¸æˆçŠ¶æ€
        const game = {
            width: window.innerWidth,
            height: window.innerHeight,
            camera: { x: 0, y: 0, zoom: 1, targetZoom: 1 },
            particles: [],
            foods: [],
            enemies: [],
            evolutionStage: 0,
            dna: 0,
            totalMass: 0,
            gameTime: 0,
            running: false,
            joystick: { active: false, dx: 0, dy: 0, originX: 0, originY: 0 },
            startTime: 0,
            deathCount: 0,
            kills: 0,
            gravityRange: 300,
            baseViewRange: 800,
            victoryShown: false
        };

        // ç©å®¶
        const player = {
            x: 0,
            y: 0,
            radius: 10,
            mass: 10,
            vx: 0,
            vy: 0,
            speed: 2.5,
            maxSpeed: 5,
            senseRange: 120,
            efficiency: 1,
            color: '#00ff88',
            abilities: {
                boost: { cooldown: 0, maxCooldown: 150, active: false },
                split: { cooldown: 0, maxCooldown: 500, active: false },
                shield: { cooldown: 0, maxCooldown: 800, active: false, duration: 0 },
                quantum: { cooldown: 0, maxCooldown: 900, active: false, ready: false },
                // è¶…çº§æŠ€èƒ½
                laser: { cooldown: 0, maxCooldown: 3000, active: false }, // 50s
                devour: { cooldown: 0, maxCooldown: 3000, active: false }, // 50s
                supercell: { cooldown: 0, maxCooldown: 3600, active: false, duration: 0 }, // 60s CD, 20s duration
                instakill: { cooldown: 0, maxCooldown: 6000, active: false }, // 100s
                track: { cooldown: 0, maxCooldown: 3000, active: false, duration: 0, target: null } // 50s
            },
            trail: [],
            unlockedEvolutions: ['basic'],
            isDead: false,
            invincible: 0,
            gravityStrength: 1,
            viewMultiplier: 1,
            feignDeath: { available: false, used: false },
            inDangerousGravity: false,
            superMode: false // è¶…çº§ç»†èƒæ¨¡å¼
        };

        // è¿›åŒ–æ ‘ - æ–°å¢èŒç‹è¡€ç»Ÿ
        const evolutionTree = [
            // åŸºç¡€è¿›åŒ–
            { id: 'membrane', name: 'å¼ºåŒ–è†œ', desc: 'å‡å°‘è¢«åå™¬æŸå¤±', cost: 50, requires: ['basic'], icon: 'ğŸ›¡ï¸', stats: { defense: 0.3 } },
            { id: 'flagella', name: 'é­æ¯›', desc: 'ç§»åŠ¨é€Ÿåº¦+50%', cost: 80, requires: ['basic'], icon: 'âš¡', stats: { speed: 1.5 } },
            { id: 'cilia', name: 'çº¤æ¯›', desc: 'è½¬å‘æ›´çµæ´»', cost: 100, requires: ['basic'], icon: 'ğŸŒ€', stats: { agility: 1.3 } },
            { id: 'gravity', name: 'å¼•åŠ›å¼ºåŒ–', desc: 'å¼•åŠ›èŒƒå›´+50%', cost: 120, requires: ['basic'], icon: 'ğŸŒŒ', stats: { gravity: 1.5 } },
            { id: 'eye', name: 'çœ¼ç‚¹è¿›åŒ–', desc: 'è§†é‡èŒƒå›´+30%', cost: 150, requires: ['basic'], icon: 'ğŸ‘ï¸', stats: { view: 1.3 } },
            
            // ä¸­çº§è¿›åŒ–
            { id: 'feign', name: 'å‡æ­»', desc: 'å…ç–«ä¸€æ¬¡è‡´å‘½ä¼¤å®³ï¼ˆä¸€æ¬¡æ€§ï¼‰', cost: 200, requires: ['membrane'], icon: 'ğŸ’€', stats: { feign: true }, consumable: true },
            { id: 'chloroplast', name: 'å¶ç»¿ä½“', desc: 'é™æ­¢æ¢å¤è´¨é‡', cost: 200, requires: ['membrane'], icon: 'ğŸŒ¿', stats: { photosynthesis: true } },
            { id: 'mitochondria', name: 'çº¿ç²’ä½“', desc: 'æŠ€èƒ½å†·å´-30%', cost: 250, requires: ['flagella'], icon: 'âš¡', stats: { efficiency: 1.3 } },
            { id: 'lens', name: 'æ™¶çŠ¶ä½“', desc: 'è§†é‡èŒƒå›´+50%', cost: 300, requires: ['eye'], icon: 'ğŸ”', stats: { view: 1.5 } },
            { id: 'supergravity', name: 'è¶…å¼•åŠ›', desc: 'å¼•åŠ›å¼ºåº¦ç¿»å€', cost: 350, requires: ['gravity'], icon: 'âš«', stats: { gravityStrength: 2 } },
            
            // é«˜çº§è¿›åŒ–
            { id: 'quantum', name: 'æ¦‚ç‡äº‘', desc: 'è¢«å¤§å‹ç»†èƒå¸å¼•æ—¶å¯åœ¨å¼•åŠ›èŒƒå›´å†…ç¬ç§»ï¼ˆ15ç§’å†·å´ï¼‰', cost: 400, requires: ['lens', 'mitochondria'], icon: 'âš›ï¸', stats: { quantum: true } },
            { id: 'toxin', name: 'æ¯’ç´ ', desc: 'å‡ç¼“é™„è¿‘æ•Œäºº', cost: 400, requires: ['chloroplast', 'mitochondria'], icon: 'â˜ ï¸', stats: { toxin: true } },
            { id: 'carnivore', name: 'æ•é£Ÿè€…', desc: 'åå™¬åŒå€æ”¶ç›Š', cost: 500, requires: ['mitochondria', 'lens'], icon: 'ğŸ¦ˆ', stats: { carnivore: 2 } },
            
            // æ–°å¢èŒç‹è¡€ç»Ÿ
            { id: 'fungus', name: 'èŒç‹è¡€ç»Ÿ', desc: 'å¼•åŠ›èŒƒå›´å†…æ‰€æœ‰ç»†èƒè¢«å®šä½ï¼ˆé™¤è‡ªå·±ï¼‰', cost: 800, requires: ['supergravity', 'toxin'], icon: 'ğŸ‘‘', stats: { fungus: true } },
            
            // è¶…çº§æŠ€èƒ½ï¼ˆæ— å‰ç½®æ¡ä»¶ï¼‰
            { id: 'supercell', name: 'è¶…çº§ç»†èƒ', desc: '20så†…æ— æ•Œ+é€Ÿåº¦å¢å¼º+å¸å¼•åŠ›æ›´å¤§ï¼ŒCD:60s', cost: 500, requires: ['basic'], icon: 'ğŸ¦¸', stats: { supercell: true }, super: true },
            { id: 'track', name: 'æ°”æ¯è¿½è¸ª', desc: 'è‡ªåŠ¨é”å®šå°ç»†èƒå¹¶é¿å¼€å¤§ç»†èƒï¼ŒCD:50s', cost: 500, requires: ['basic'], icon: 'ğŸ¯', stats: { track: true }, super: true },
            { id: 'devour', name: 'å…¨å›¾åå™¬', desc: 'åå™¬å…¨å›¾æ‰€æœ‰æ¯”è‡ªå·±å°çš„æ•Œäººï¼ŒCD:50s', cost: 999, requires: ['basic'], icon: 'ğŸŒŒ', stats: { devour: true }, super: true },
            { id: 'laser', name: 'æ¯ç­æ¿€å…‰', desc: 'æ‘§æ¯ä¸€æ¡çº¿ä¸Šçš„æ‰€æœ‰æ•Œäººï¼ŒCD:50s', cost: 1000, requires: ['basic'], icon: 'ğŸ”¥', stats: { laser: true }, super: true },
            { id: 'instakill', name: 'ç§’æ€ä¸€åˆ‡', desc: 'ç§’æ€è‡ªå·±å¼•åŠ›èŒƒå›´å†…ä¸€åˆ‡ç»†èƒï¼ŒCD:100s', cost: 3000, requires: ['basic'], icon: 'ğŸ’€', stats: { instakill: true }, super: true },
            
            // ç»ˆæè¿›åŒ–
            { id: 'multicell', name: 'å¤šç»†èƒ', desc: 'æ§åˆ¶å¤šä¸ªåˆ†èº«', cost: 1000, requires: ['toxin', 'carnivore'], icon: 'ğŸ”·', stats: { multicell: true } }
        ];

        // æ»šåŠ¨çŠ¶æ€
        let scrollState = {
            isScrolling: false,
            startY: 0,
            currentY: 0,
            velocity: 0,
            contentHeight: 0,
            containerHeight: 0,
            maxScroll: 0
        };

        // åˆå§‹åŒ–
        function init() {
            resize();
            window.addEventListener('resize', resize);
            setupJoystick();
            setupSkills();
            setupEvolution();
            setupScroll();
            renderMinimap();

            // è®¾ç½®æ›´æ–°æ—¥å¿—å†…å®¹
            document.getElementById('changelog-content').innerHTML = changelogHTML;
            
            // æ˜¾ç¤ºä½œè€…æç¤º
            setTimeout(() => {
                showNotification('åŸåˆ›ä½œè€…:STN Studio');
            }, 1000);
        }

        function resize() {
            game.width = window.innerWidth;
            game.height = window.innerHeight;
            canvas.width = game.width;
            canvas.height = game.height;
            minimapCanvas.width = 100;
            minimapCanvas.height = 100;
        }

        // æ˜¾ç¤º/å…³é—­æ›´æ–°æ—¥å¿—
        function showChangelog() {
            document.getElementById('changelog-panel').classList.add('show');
        }

        function closeChangelog() {
            document.getElementById('changelog-panel').classList.remove('show');
        }

        function startGame() {
            document.getElementById('start-screen').classList.add('hidden');
            resetGame();
            game.running = true;
            game.startTime = Date.now();

            for (let i = 0; i < 80; i++) spawnFood();
            for (let i = 0; i < 15; i++) spawnEnemy();

            gameLoop();
        }

        function resetGame() {
            player.x = 0;
            player.y = 0;
            player.vx = 0;
            player.vy = 0;
            player.mass = 10;
            player.radius = Math.sqrt(10) * 3;
            player.isDead = false;
            player.invincible = 180;
            player.trail = [];
            player.gravityStrength = 1;
            player.viewMultiplier = 1;
            player.feignDeath = { available: false, used: false };
            player.inDangerousGravity = false;
            player.superMode = false;

            for (let key in player.abilities) {
                player.abilities[key].cooldown = 0;
                player.abilities[key].active = false;
                if (key === 'quantum') player.abilities[key].ready = false;
            }

            game.camera = { x: 0, y: 0, zoom: 1, targetZoom: 1 };
            game.particles = [];
            game.foods = [];
            game.enemies = [];
            game.gameTime = 0;
            game.evolutionStage = 0;
            game.kills = 0;
            game.victoryShown = false;

            game.joystick.active = false;
            game.joystick.dx = 0;
            game.joystick.dy = 0;
            const knob = document.getElementById('joystick-knob');
            knob.style.transform = `translate(-50%, -50%)`;
            knob.classList.remove('active');

            // é‡ç½®UI
            document.getElementById('feign-death-indicator').classList.remove('active');
            document.getElementById('quantum-ready').classList.remove('active');
            document.getElementById('super-mode-indicator').classList.remove('active');
            document.getElementById('skill-quantum').classList.add('hidden');

            // éšè—æ‰€æœ‰è¶…çº§æŠ€èƒ½æŒ‰é’®
            ['laser', 'devour', 'supercell', 'insta', 'track'].forEach(id => {
                document.getElementById('skill-' + id).classList.add('hidden');
            });
        }

        function respawn() {
            document.getElementById('death-screen').classList.remove('show');
            game.deathCount++;
            resetGame();
            game.running = true;
            game.startTime = Date.now();

            for (let i = 0; i < 80; i++) spawnFood();
            for (let i = 0; i < 15; i++) spawnEnemy();

            showNotification(`ğŸ”„ ç¬¬${game.deathCount + 1}æ¬¡ç”Ÿå‘½`);
            gameLoop();
        }

        // èƒœåˆ©ç•Œé¢
        function showVictory() {
            if (game.victoryShown) return;
            game.victoryShown = true;

            const survivalTime = Math.floor((Date.now() - game.startTime) / 1000);

            document.getElementById('victory-mass').textContent = Math.floor(player.mass);
            document.getElementById('victory-dna').textContent = Math.floor(game.dna);
            document.getElementById('victory-time').textContent = survivalTime + 's';
            document.getElementById('victory-kills').textContent = game.kills;

            document.getElementById('victory-screen').classList.add('show');
        }

        function continueGame() {
            document.getElementById('victory-screen').classList.remove('show');
            showNotification('ğŸ‘‘ ç»§ç»­è¿›åŒ–ä¹‹è·¯ï¼');
        }

        function endGame() {
            document.getElementById('victory-screen').classList.remove('show');
            document.getElementById('start-screen').classList.remove('hidden');
            resetGame();
        }

        // è™šæ‹Ÿæ‘‡æ†
        function setupJoystick() {
            const zone = document.getElementById('joystick-zone');
            const knob = document.getElementById('joystick-knob');

            let startX, startY;

            zone.addEventListener('touchstart', (e) => {
                if (player.isDead) return;
                e.preventDefault();
                const touch = e.touches[0];
                const rect = zone.getBoundingClientRect();
                startX = rect.left + rect.width / 2;
                startY = rect.top + rect.height / 2;

                game.joystick.active = true;
                updateJoystick(touch.clientX, touch.clientY);
                knob.classList.add('active');
            }, { passive: false });

            zone.addEventListener('touchmove', (e) => {
                if (player.isDead) return;
                e.preventDefault();
                if (!game.joystick.active) return;
                updateJoystick(e.touches[0].clientX, e.touches[0].clientY);
            }, { passive: false });

            zone.addEventListener('touchend', (e) => {
                e.preventDefault();
                game.joystick.active = false;
                game.joystick.dx = 0;
                game.joystick.dy = 0;
                knob.style.transform = `translate(-50%, -50%)`;
                knob.classList.remove('active');
            });

            function updateJoystick(clientX, clientY) {
                const maxDist = 35;
                let dx = clientX - startX;
                let dy = clientY - startY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > maxDist) {
                    dx = (dx / dist) * maxDist;
                    dy = (dy / dist) * maxDist;
                }

                knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;

                game.joystick.dx = dx / maxDist;
                game.joystick.dy = dy / maxDist;
            }
        }

        // æŠ€èƒ½æŒ‰é’®
        function setupSkills() {
            document.querySelectorAll('.skill-btn').forEach(btn => {
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (player.isDead) return;
                    useSkill(btn.dataset.skill);
                }, { passive: false });
            });
        }

        function useSkill(skill) {
            if (player.isDead) return;
            const ability = player.abilities[skill];
            if (ability.cooldown > 0) return;

            switch(skill) {
                case 'boost':
                    if (player.mass > 20) {
                        ability.active = true;
                        ability.cooldown = ability.maxCooldown;
                        const speed = Math.sqrt(player.vx**2 + player.vy**2);
                        if (speed > 0) {
                            player.vx = (player.vx / speed) * player.maxSpeed * 4;
                            player.vy = (player.vy / speed) * player.maxSpeed * 4;
                        } else {
                            player.vx = game.joystick.dx * player.maxSpeed * 4;
                            player.vy = game.joystick.dy * player.maxSpeed * 4;
                        }
                        player.mass -= 5;
                        showNotification('âš¡ åŠ é€Ÿé€ƒè„±!');
                        createParticle(player.x, player.y, '#00ff88', 8);
                    }
                    break;

                case 'split':
                    if (player.mass > 50) {
                        ability.active = true;
                        ability.cooldown = ability.maxCooldown;
                        player.mass *= 0.5;
                        player.vx += game.joystick.dx * 15;
                        player.vy += game.joystick.dy * 15;
                        showNotification('ğŸ”„ åˆ†è£‚é€ƒè„±!');
                        createExplosion(player.x, player.y, '#00ff88');
                    }
                    break;

                case 'shield':
                    ability.active = true;
                    ability.duration = 150;
                    ability.cooldown = ability.maxCooldown;
                    showNotification('ğŸ›¡ï¸ æŠ¤ç›¾å…ç–«å¼•åŠ›!');
                    break;

                case 'quantum':
                    if (ability.ready && player.inDangerousGravity) {
                        quantumTeleport();
                    } else if (!player.inDangerousGravity) {
                        showNotification('âš›ï¸ åªæœ‰åœ¨è¢«å¤§ç»†èƒå¸å¼•æ—¶æ‰èƒ½ä½¿ç”¨!');
                    } else {
                        showNotification('âš›ï¸ å†·å´ä¸­...');
                    }
                    break;

                // è¶…çº§æŠ€èƒ½
                case 'laser':
                    useLaser();
                    break;

                case 'devour':
                    useDevour();
                    break;

                case 'supercell':
                    useSuperCell();
                    break;

                case 'instakill':
                    useInstaKill();
                    break;

                case 'track':
                    useTrack();
                    break;
            }
        }

        // ========== è¶…çº§æŠ€èƒ½å®ç° ==========

        // 1. æ¯ç­æ¿€å…‰
        function useLaser() {
            const ability = player.abilities.laser;
            ability.cooldown = ability.maxCooldown;

            // è·å–ç§»åŠ¨æ–¹å‘
            let angle = Math.atan2(player.vy, player.vx);
            if (player.vx === 0 && player.vy === 0) {
                angle = Math.atan2(game.joystick.dy, game.joystick.dx);
            }

            // æ¿€å…‰èŒƒå›´
            const laserLength = 2000;
            const laserWidth = 50;

            // è®¡ç®—æ¿€å…‰èµ·ç‚¹å’Œç»ˆç‚¹
            const startX = player.x;
            const startY = player.y;
            const endX = player.x + Math.cos(angle) * laserLength;
            const endY = player.y + Math.sin(angle) * laserLength;

            // æ£€æµ‹æ¿€å…‰çº¿ä¸Šçš„æ•Œäºº
            let killCount = 0;
            for (let i = game.enemies.length - 1; i >= 0; i--) {
                const enemy = game.enemies[i];
                const dist = pointToLineDistance(enemy.x, enemy.y, startX, startY, endX, endY);

                if (dist < laserWidth + enemy.radius) {
                    // æ‘§æ¯æ•Œäºº
                    createExplosion(enemy.x, enemy.y, '#ff0000');
                    game.enemies.splice(i, 1);
                    killCount++;
                }
            }

            // æ¿€å…‰è§†è§‰æ•ˆæœ
            for (let i = 0; i < 50; i++) {
                const t = i / 50;
                const px = startX + (endX - startX) * t;
                const py = startY + (endY - startY) * t;
                createParticle(px, py, '#ff0000', 3);
                createParticle(px, py, '#ffff00', 2);
            }

            showNotification(`ğŸ”¥ æ¯ç­æ¿€å…‰! æ‘§æ¯${killCount}ä¸ªæ•Œäºº!`);
        }

        // è®¡ç®—ç‚¹åˆ°çº¿æ®µçš„è·ç¦»
        function pointToLineDistance(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;

            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;

            if (lenSq !== 0) param = dot / lenSq;

            let xx, yy;

            if (param < 0) {
                xx = x1;
                yy = y1;
            } else if (param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }

            const dx = px - xx;
            const dy = py - yy;

            return Math.sqrt(dx * dx + dy * dy);
        }

        // 2. å…¨å›¾åå™¬
        function useDevour() {
            const ability = player.abilities.devour;
            ability.cooldown = ability.maxCooldown;

            let devourCount = 0;
            let totalGain = 0;

            for (let i = game.enemies.length - 1; i >= 0; i--) {
                const enemy = game.enemies[i];
                if (player.mass > enemy.mass) {
                    const gain = enemy.mass * 0.5;
                    player.mass += gain;
                    totalGain += gain;
                    devourCount++;

                    // åˆ›å»ºåå™¬ç‰¹æ•ˆ
                    createParticle(enemy.x, enemy.y, '#00ff88', 5);

                    // ä»å…¨å›¾å„æ–¹å‘é£å‘ç©å®¶
                    const dx = player.x - enemy.x;
                    const dy = player.y - enemy.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    game.enemies.splice(i, 1);
                }
            }

            // å…¨å›¾ç‰¹æ•ˆ
            for (let i = 0; i < 100; i++) {
                const angle = (Math.PI * 2 / 100) * i;
                const dist = 500 + Math.random() * 1000;
                const px = player.x + Math.cos(angle) * dist;
                const py = player.y + Math.sin(angle) * dist;
                createParticle(px, py, '#00ff88', 2);
            }

            createExplosion(player.x, player.y, '#00ff88');
            showNotification(`ğŸŒŒ å…¨å›¾åå™¬! åå™¬${devourCount}ä¸ªæ•Œäºº! +${Math.floor(totalGain)}è´¨é‡!`);
        }

        // 3. è¶…çº§ç»†èƒ
        function useSuperCell() {
            const ability = player.abilities.supercell;
            ability.cooldown = ability.maxCooldown;
            ability.duration = 1200; // 20ç§’ = 1200å¸§

            player.superMode = true;
            player.invincible = 1200;

            // å¢å¼ºå±æ€§
            const originalSpeed = player.speed;
            const originalGravity = game.gravityRange;

            player.speed *= 2;
            game.gravityRange *= 3;

            showNotification('ğŸ¦¸ è¶…çº§ç»†èƒæ¨¡å¼å¯åŠ¨! 20ç§’æ— æ•Œ!');
            document.getElementById('super-mode-indicator').classList.add('active');

            // 20ç§’åæ¢å¤
            setTimeout(() => {
                if (!player.isDead) {
                    player.superMode = false;
                    player.speed = originalSpeed;
                    game.gravityRange = originalGravity;
                    document.getElementById('super-mode-indicator').classList.remove('active');
                    showNotification('è¶…çº§æ¨¡å¼ç»“æŸ');
                }
            }, 20000);
        }

        // 4. ç§’æ€ä¸€åˆ‡
        function useInstaKill() {
            const ability = player.abilities.instakill;
            ability.cooldown = ability.maxCooldown;

            const myGravityRange = game.gravityRange * Math.sqrt(player.mass / 10) * player.gravityStrength;

            let killCount = 0;

            for (let i = game.enemies.length - 1; i >= 0; i--) {
                const enemy = game.enemies[i];
                const dx = enemy.x - player.x;
                const dy = enemy.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < myGravityRange) {
                    // ç§’æ€ç‰¹æ•ˆ
                    createExplosion(enemy.x, enemy.y, '#800080');

                    // ç´«è‰²ç²’å­
                    for (let j = 0; j < 10; j++) {
                        game.particles.push({
                            x: enemy.x,
                            y: enemy.y,
                            vx: (Math.random() - 0.5) * 10,
                            vy: (Math.random() - 0.5) * 10,
                            life: 40,
                            maxLife: 40,
                            color: '#ff00ff',
                            size: Math.random() * 5 + 3
                        });
                    }

                    game.enemies.splice(i, 1);
                    killCount++;
                }
            }

            // ç©å®¶ç‰¹æ•ˆ
            createExplosion(player.x, player.y, '#ff00ff');

            showNotification(`ğŸ’€ ç§’æ€ä¸€åˆ‡! æ¶ˆç­${killCount}ä¸ªæ•Œäºº!`);
        }

        // 5. æ°”æ¯è¿½è¸ª
        function useTrack() {
            const ability = player.abilities.track;
            ability.cooldown = ability.maxCooldown;
            ability.duration = 1500; // 25ç§’
            ability.target = null;

            // å¯»æ‰¾æœ€è¿‘çš„å°ç»†èƒä½œä¸ºç›®æ ‡
            let nearestEnemy = null;
            let nearestDist = Infinity;

            game.enemies.forEach(enemy => {
                if (enemy.mass < player.mass * 0.8) {
                    const dx = enemy.x - player.x;
                    const dy = enemy.y - player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestEnemy = enemy;
                    }
                }
            });

            if (nearestEnemy) {
                ability.target = nearestEnemy;
                showNotification('ğŸ¯ æ°”æ¯è¿½è¸ªå¯åŠ¨! è‡ªåŠ¨ç‹©çŒ!');
            } else {
                showNotification('ğŸ¯ èŒƒå›´å†…æ²¡æœ‰å¯è¿½è¸ªçš„ç›®æ ‡!');
                ability.duration = 0;
            }
        }

        // æ¦‚ç‡äº‘ç¬ç§»
        function quantumTeleport() {
            const ability = player.abilities.quantum;
            ability.ready = false;
            ability.cooldown = ability.maxCooldown;

            const myGravityRange = game.gravityRange * Math.sqrt(player.mass / 10) * player.gravityStrength;
            const angle = Math.random() * Math.PI * 2;
            const distance = myGravityRange * (0.5 + Math.random() * 0.5);

            const oldX = player.x;
            const oldY = player.y;

            player.x += Math.cos(angle) * distance;
            player.y += Math.sin(angle) * distance;

            player.vx = 0;
            player.vy = 0;

            createExplosion(oldX, oldY, '#00ccff');
            createExplosion(player.x, player.y, '#00ccff');

            for (let i = 0; i < 20; i++) {
                const pAngle = (Math.PI * 2 / 20) * i;
                game.particles.push({
                    x: oldX,
                    y: oldY,
                    vx: Math.cos(pAngle) * 3,
                    vy: Math.sin(pAngle) * 3,
                    life: 40,
                    maxLife: 40,
                    color: '#00ccff',
                    size: Math.random() * 4 + 2
                });
            }

            showNotification('âš›ï¸ æ¦‚ç‡äº‘ç¬ç§»!');

            document.getElementById('quantum-ready').classList.remove('active');
            document.getElementById('skill-quantum').classList.remove('ready');
        }

        // è¿›åŒ–ç³»ç»Ÿ
        function setupEvolution() {
            document.getElementById('evolution-btn').addEventListener('click', () => {
                if (!player.isDead) {
                    openEvolution();
                    updateScrollDimensions();
                }
            });
            updateEvolutionUI();
        }

        function openEvolution() {
            document.getElementById('evolution-panel').classList.add('show');
            updateEvolutionUI();
            scrollState.currentY = 0;
            updateScrollPosition();
        }

        function closeEvolution() {
            document.getElementById('evolution-panel').classList.remove('show');
        }

        // åŒæŒ‡æ»‘åŠ¨ç³»ç»Ÿ
        function setupScroll() {
            const container = document.getElementById('scroll-container');
            const content = document.getElementById('scroll-content');

            let isTwoFinger = false;

            container.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    isTwoFinger = true;
                    scrollState.isScrolling = true;

                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    const initialY = (touch1.clientY + touch2.clientY) / 2;

                    scrollState.startY = initialY - scrollState.currentY;
                    scrollState.velocity = 0;

                    e.preventDefault();
                }
            }, { passive: false });

            container.addEventListener('touchmove', (e) => {
                if (!isTwoFinger || e.touches.length !== 2) return;

                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                const currentY = (touch1.clientY + touch2.clientY) / 2;

                const newY = currentY - scrollState.startY;
                const deltaY = newY - scrollState.currentY;

                scrollState.velocity = deltaY;
                scrollState.currentY = newY;

                if (scrollState.currentY > 0) {
                    scrollState.currentY = 0;
                    scrollState.velocity = 0;
                } else if (scrollState.currentY < -scrollState.maxScroll) {
                    scrollState.currentY = -scrollState.maxScroll;
                    scrollState.velocity = 0;
                }

                updateScrollPosition();
                e.preventDefault();
            }, { passive: false });

            container.addEventListener('touchend', (e) => {
                if (isTwoFinger) {
                    isTwoFinger = false;
                    scrollState.isScrolling = false;

                    if (Math.abs(scrollState.velocity) > 2) {
                        requestAnimationFrame(inertiaScroll);
                    }
                }
            });

            content.addEventListener('click', (e) => {
                const card = e.target.closest('.evolution-card');
                if (card && card.classList.contains('available')) {
                    const index = Array.from(content.querySelectorAll('.evolution-card')).indexOf(card);
                    const evo = evolutionTree[index];
                    if (evo) unlockEvolution(evo);
                }
            });
        }

        function inertiaScroll() {
            if (scrollState.isScrolling) return;

            scrollState.velocity *= 0.95;

            scrollState.currentY += scrollState.velocity;

            if (scrollState.currentY > 0) {
                scrollState.currentY = 0;
                scrollState.velocity = 0;
            } else if (scrollState.currentY < -scrollState.maxScroll) {
                scrollState.currentY = -scrollState.maxScroll;
                scrollState.velocity = 0;
            }

            updateScrollPosition();

            if (Math.abs(scrollState.velocity) > 0.5) {
                requestAnimationFrame(inertiaScroll);
            }
        }

        function updateScrollPosition() {
            const content = document.getElementById('scroll-content');
            content.style.transform = `translateY(${scrollState.currentY}px)`;
        }

        function updateScrollDimensions() {
            const container = document.getElementById('scroll-container');
            const content = document.getElementById('scroll-content');

            scrollState.containerHeight = container.clientHeight;
            scrollState.contentHeight = content.scrollHeight;
            scrollState.maxScroll = Math.max(0, scrollState.contentHeight - scrollState.containerHeight);
        }

        function updateEvolutionUI() {
            const list = document.getElementById('evolution-list');
            const dna = game.dna;
            document.getElementById('panel-dna').textContent = Math.floor(dna) + ' DNA';

            let hasAvailable = false;

            list.innerHTML = '';
            evolutionTree.forEach(evo => {
                const canUnlock = evo.requires.every(r => player.unlockedEvolutions.includes(r));
                const isUnlocked = player.unlockedEvolutions.includes(evo.id);
                const hasCost = dna >= evo.cost;

                let isAvailable = canUnlock && hasCost && !isUnlocked;
                let showStatus = '';

                if (evo.id === 'feign' && isUnlocked) {
                    if (player.feignDeath.available && !player.feignDeath.used) {
                        showStatus = '<div class="evo-status ready">å°±ç»ª</div>';
                    } else if (player.feignDeath.used) {
                        showStatus = '<div class="evo-status used">å·²ä½¿ç”¨</div>';
                        isAvailable = true;
                    }
                }

                if (isAvailable) hasAvailable = true;

                const card = document.createElement('div');
                card.className = 'evolution-card';
                if (evo.super) card.classList.add('super');
                if (isUnlocked && evo.id !== 'feign') card.classList.add('unlocked');
                else if (isAvailable) {
                    card.classList.add('available');
                } else {
                    card.classList.add('locked');
                }

                const costText = evo.consumable && isUnlocked && player.feignDeath.used ? 'é‡æ–°è´­ä¹°' : (isUnlocked ? 'å·²è§£é”' : evo.cost + ' DNA');

                card.innerHTML = `
                    <div class="evo-icon">${evo.icon}</div>
                    <div class="evo-name">${evo.name}</div>
                    <div class="evo-desc">${evo.desc}</div>
                    <div class="evo-cost ${isUnlocked && !evo.consumable ? 'paid' : ''}">${costText}</div>
                    ${showStatus}
                `;

                list.appendChild(card);
            });

            setTimeout(updateScrollDimensions, 100);

            const badge = document.getElementById('evo-badge');
            const btn = document.getElementById('evolution-btn');
            if (hasAvailable && !player.isDead) {
                badge.classList.remove('hidden');
                btn.classList.add('pulse');
            } else {
                badge.classList.add('hidden');
                btn.classList.remove('pulse');
            }
        }

        function unlockEvolution(evo) {
            // å¤„ç†ä¸€æ¬¡æ€§é“å…·é‡æ–°è´­ä¹°
            if (evo.consumable && player.unlockedEvolutions.includes(evo.id)) {
                if (evo.id === 'feign' && player.feignDeath.used && game.dna >= evo.cost) {
                    game.dna -= evo.cost;
                    player.feignDeath.used = false;
                    player.feignDeath.available = true;
                    showNotification(`ğŸ’€ å‡æ­»é‡æ–°å°±ç»ª!`);
                    updateEvolutionUI();
                    return;
                }
                return;
            }

            if (game.dna >= evo.cost && !player.unlockedEvolutions.includes(evo.id)) {
                game.dna -= evo.cost;
                player.unlockedEvolutions.push(evo.id);

                if (evo.stats.speed) player.speed *= evo.stats.speed;
                if (evo.stats.sense) player.senseRange *= evo.stats.sense;
                if (evo.stats.efficiency) player.efficiency *= evo.stats.efficiency;
                if (evo.stats.gravity) game.gravityRange *= evo.stats.gravity;
                if (evo.stats.gravityStrength) player.gravityStrength *= evo.stats.gravityStrength;
                if (evo.stats.view) player.viewMultiplier *= evo.stats.view;

                // å‡æ­»
                if (evo.stats.feign) {
                    player.feignDeath.available = true;
                    player.feignDeath.used = false;
                    document.getElementById('feign-death-indicator').classList.add('active');
                }

                // èŒç‹è¡€ç»Ÿ
                if (evo.stats.fungus) {
                    showNotification('ğŸ‘‘ èŒç‹è¡€ç»Ÿè§‰é†’ï¼å¼•åŠ›èŒƒå›´å†…æ•Œäººå°†è¢«å®šä½ï¼');
                }

                // æ¦‚ç‡äº‘
                if (evo.stats.quantum) {
                    document.getElementById('skill-quantum').classList.remove('hidden');
                    player.abilities.quantum.ready = true;
                    document.getElementById('quantum-ready').classList.add('active');
                    document.getElementById('skill-quantum').classList.add('ready');
                }

                // è¶…çº§æŠ€èƒ½
                if (evo.stats.laser) {
                    document.getElementById('skill-laser').classList.remove('hidden');
                }
                if (evo.stats.devour) {
                    document.getElementById('skill-devour').classList.remove('hidden');
                }
                if (evo.stats.supercell) {
                    document.getElementById('skill-supercell').classList.remove('hidden');
                }
                if (evo.stats.instakill) {
                    document.getElementById('skill-insta').classList.remove('hidden');
                }
                if (evo.stats.track) {
                    document.getElementById('skill-track').classList.remove('hidden');
                }

                showNotification(`ğŸ§¬ è¿›åŒ–: ${evo.name}!`);
                updateEvolutionUI();
                createExplosion(player.x, player.y, '#00ff88');
            }
        }

        // è®¡ç®—åŠ¨æ€è§†é‡ç¼©æ”¾
        function updateCameraZoom() {
            const baseView = game.height / 2;
            const massFactor = Math.pow(player.mass / 10, 0.4);
            const viewRange = game.baseViewRange * massFactor * player.viewMultiplier;
            const targetZoom = Math.min(1, baseView / (player.radius * 4));

            game.camera.targetZoom = targetZoom;
            game.camera.zoom += (game.camera.targetZoom - game.camera.zoom) * 0.05;
            game.camera.zoom = Math.max(0.3, Math.min(1.2, game.camera.zoom));

            const viewPercent = Math.round(game.camera.zoom * 100);
            document.getElementById('view-range').textContent = viewPercent + '%';
        }

        // è®¡ç®—å¼•åŠ›
        function calculateGravity(myMass, otherMass, distance) {
            const massDiff = myMass - otherMass;
            const minDistance = 50;

            if (distance < minDistance) distance = minDistance;

            let force = (massDiff / (distance * distance)) * 10000;
            return force;
        }

        // æ¸¸æˆé€»è¾‘
        function update() {
            if (!game.running || player.isDead) return;
            game.gameTime++;

            updateCameraZoom();

            if (player.invincible > 0) {
                player.invincible--;
                if (player.invincible === 0 && !player.superMode) showNotification('æ— æ•Œç»“æŸ!');
            }

            // æ›´æ–°è¶…çº§æŠ€èƒ½å†·å´
            updateSuperSkillsCooldown();

            // æ›´æ–°æ¦‚ç‡äº‘å†·å´
            updateQuantumCooldown();

            // æ›´æ–°æ°”æ¯è¿½è¸ª
            updateTrack();

            updateSkills();

            if (game.joystick.active) {
                player.vx += game.joystick.dx * 0.3 * player.speed;
                player.vy += game.joystick.dy * 0.3 * player.speed;
            }

            applyGravityEffects();

            // èŒç‹è¡€ç»Ÿæ•ˆæœ - å®šä½å¼•åŠ›èŒƒå›´å†…çš„æ•Œäºº
            if (player.unlockedEvolutions.includes('fungus')) {
                const fungusRange = game.gravityRange * Math.sqrt(player.mass / 10) * player.gravityStrength;
                game.enemies.forEach(enemy => {
                    const dx = enemy.x - player.x;
                    const dy = enemy.y - player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < fungusRange && dist > 0) {
                        // å®šä½æ•Œäººï¼Œæ— æ³•ç§»åŠ¨
                        enemy.vx = 0;
                        enemy.vy = 0;
                        
                        // æ·»åŠ å®šèº«ç‰¹æ•ˆ
                        if (game.gameTime % 10 === 0) {
                            createParticle(enemy.x, enemy.y, '#8B4513', 1);
                        }
                    }
                });
                
                // èŒç‹å…‰ç¯ç‰¹æ•ˆ
                if (game.gameTime % 30 === 0) {
                    for (let i = 0; i < 8; i++) {
                        const angle = (Math.PI * 2 / 8) * i;
                        const px = player.x + Math.cos(angle) * (fungusRange * 0.9);
                        const py = player.y + Math.sin(angle) * (fungusRange * 0.9);
                        createParticle(px, py, '#8B4513', 1);
                    }
                }
            }

            player.vx *= 0.92;
            player.vy *= 0.92;

            if (player.abilities.shield.active) {
                player.vx *= 0.6;
                player.vy *= 0.6;
            }

            player.x += player.vx;
            player.y += player.vy;

            player.radius = Math.sqrt(player.mass) * 3;

            if (game.gameTime % 4 === 0) {
                player.trail.push({ x: player.x, y: player.y, alpha: 1 });
                if (player.trail.length > 15) player.trail.shift();
            }
            player.trail.forEach(t => t.alpha *= 0.9);

            const boundary = 3000;
            player.x = Math.max(-boundary, Math.min(boundary, player.x));
            player.y = Math.max(-boundary, Math.min(boundary, player.y));

            game.camera.x += (player.x - game.camera.x) * 0.15;
            game.camera.y += (player.y - game.camera.y) * 0.15;

            if (player.unlockedEvolutions.includes('chloroplast')) {
                if (Math.abs(player.vx) < 0.5 && Math.abs(player.vy) < 0.5) {
                    if (game.gameTime % 60 === 0) {
                        player.mass += 0.2 * player.efficiency;
                        createParticle(player.x, player.y, '#00ff00', 1);
                    }
                }
            }

            updateFoods();
            updateEnemies();
            updateParticles();

            if (game.gameTime % 40 === 0 && game.foods.length < 100) spawnFood();
            if (game.gameTime % 150 === 0 && game.enemies.length < 25) spawnEnemy();

            checkEvolution();

            if (player.mass <= 1) die();

            const warning = document.getElementById('health-warning');
            if (player.mass < 15 && player.mass > 1) {
                warning.classList.add('show');
                if (game.gameTime % 30 === 0) showNotification('âš ï¸ è´¨é‡è¿‡ä½! å¯»æ‰¾é£Ÿç‰©!');
            } else {
                warning.classList.remove('show');
            }
        }

        // æ›´æ–°è¶…çº§æŠ€èƒ½å†·å´
        function updateSuperSkillsCooldown() {
            ['laser', 'devour', 'supercell', 'instakill', 'track'].forEach(skill => {
                const ability = player.abilities[skill];
                if (!player.unlockedEvolutions.includes(skill)) return;

                if (ability.cooldown > 0) {
                    ability.cooldown--;
                    const cd = Math.ceil(ability.cooldown / 60);
                    const overlay = document.getElementById('cd-' + skill);
                    const btn = document.getElementById('skill-' + skill);

                    if (cd > 0) {
                        overlay.textContent = cd;
                        overlay.classList.remove('hidden');
                        btn.classList.add('cooldown');
                        btn.classList.remove('active', 'ready');
                    } else {
                        overlay.classList.add('hidden');
                        btn.classList.remove('cooldown');
                        btn.classList.add('active', 'ready');
                    }
                } else {
                    document.getElementById('skill-' + skill).classList.add('active', 'ready');
                }

                if (ability.duration > 0) {
                    ability.duration--;
                    if (ability.duration === 0) {
                        ability.active = false;
                        if (skill === 'track') ability.target = null;
                    }
                }
            });
        }

        // æ›´æ–°æ°”æ¯è¿½è¸ª
        function updateTrack() {
            const ability = player.abilities.track;
            if (!ability.active || !ability.target) return;

            // æ£€æŸ¥ç›®æ ‡æ˜¯å¦è¿˜å­˜åœ¨
            const targetExists = game.enemies.includes(ability.target);
            if (!targetExists) {
                // å¯»æ‰¾æ–°ç›®æ ‡
                let nearestEnemy = null;
                let nearestDist = Infinity;

                game.enemies.forEach(enemy => {
                    if (enemy.mass < player.mass * 0.8) {
                        const dx = enemy.x - player.x;
                        const dy = enemy.y - player.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestEnemy = enemy;
                        }
                    }
                });

                if (nearestEnemy) {
                    ability.target = nearestEnemy;
                } else {
                    ability.active = false;
                    ability.duration = 0;
                    showNotification('ğŸ¯ è¿½è¸ªç»“æŸ: æ— ç›®æ ‡');
                    return;
                }
            }

            // è‡ªåŠ¨ç§»åŠ¨å‘ç›®æ ‡
            const dx = ability.target.x - player.x;
            const dy = ability.target.y - player.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist > 0) {
                // é¿å¼€å¤§ç»†èƒ
                let avoidX = 0, avoidY = 0;
                game.enemies.forEach(enemy => {
                    if (enemy.mass > player.mass * 1.2) {
                        const edx = player.x - enemy.x;
                        const edy = player.y - enemy.y;
                        const edist = Math.sqrt(edx * edx + edy * edy);
                        if (edist < 300) {
                            avoidX += (edx / edist) * 0.5;
                            avoidY += (edy / edist) * 0.5;
                        }
                    }
                });

                player.vx += (dx / dist) * 0.3 + avoidX;
                player.vy += (dy / dist) * 0.3 + avoidY;
            }
        }

        function updateQuantumCooldown() {
            const ability = player.abilities.quantum;
            if (!player.unlockedEvolutions.includes('quantum')) return;

            if (ability.cooldown > 0) {
                ability.cooldown--;
                const cd = Math.ceil(ability.cooldown / 60);
                const overlay = document.getElementById('cd-quantum');
                const btn = document.getElementById('skill-quantum');

                if (cd > 0) {
                    overlay.textContent = cd;
                    overlay.classList.remove('hidden');
                    btn.classList.add('cooldown');
                    btn.classList.remove('active', 'ready');
                    document.getElementById('quantum-ready').classList.remove('active');
                } else {
                    overlay.classList.add('hidden');
                    btn.classList.remove('cooldown');
                    ability.ready = true;
                    if (player.inDangerousGravity) {
                        btn.classList.add('ready');
                        document.getElementById('quantum-ready').classList.add('active');
                    }
                }
            } else if (ability.ready && !player.inDangerousGravity) {
                document.getElementById('quantum-ready').classList.remove('active');
                document.getElementById('skill-quantum').classList.remove('ready');
            }
        }

        function applyGravityEffects() {
            const myGravityRange = game.gravityRange * Math.sqrt(player.mass / 10) * player.gravityStrength;

            let totalFx = 0, totalFy = 0;
            let inDanger = false;

            game.enemies.forEach(enemy => {
                const dx = enemy.x - player.x;
                const dy = enemy.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < myGravityRange && dist > 0) {
                    const force = calculateGravity(player.mass, enemy.mass, dist);
                    const nx = dx / dist;
                    const ny = dy / dist;

                    if (player.mass > enemy.mass) {
                        const pullStrength = 0.02 * (player.mass / enemy.mass);
                        totalFx += nx * pullStrength * (myGravityRange - dist) / myGravityRange;
                        totalFy += ny * pullStrength * (myGravityRange - dist) / myGravityRange;
                    } else {
                        const dangerPull = 0.05 * (enemy.mass / player.mass);
                        totalFx += nx * dangerPull;
                        totalFy += ny * dangerPull;

                        if (enemy.mass > player.mass * 1.5 && dist < myGravityRange * 0.8) {
                            inDanger = true;
                        }
                    }
                }
            });

            player.inDangerousGravity = inDanger;

            if (inDanger && player.abilities.quantum.ready) {
                document.getElementById('quantum-ready').classList.add('active');
                document.getElementById('skill-quantum').classList.add('ready');
            }

            let resistance = player.abilities.shield.active ? 0.3 : 1;
            if (player.unlockedEvolutions.includes('membrane')) resistance *= 0.8;

            player.vx += totalFx * resistance;
            player.vy += totalFy * resistance;
        }

        function updateSkills() {
            for (let key in player.abilities) {
                if (['quantum', 'laser', 'devour', 'supercell', 'instakill', 'track'].includes(key)) continue;

                const ability = player.abilities[key];
                if (ability.cooldown > 0) {
                    ability.cooldown--;
                    const cd = Math.ceil(ability.cooldown / 60);
                    const overlay = document.getElementById('cd-' + key);
                    const btn = document.getElementById('skill-' + key);

                    if (cd > 0) {
                        overlay.textContent = cd;
                        overlay.classList.remove('hidden');
                        btn.classList.add('cooldown');
                        btn.classList.remove('active');
                    } else {
                        overlay.classList.add('hidden');
                        btn.classList.remove('cooldown');
                        btn.classList.add('active');
                    }
                } else {
                    document.getElementById('skill-' + key).classList.add('active');
                }

                if (ability.duration > 0) {
                    ability.duration--;
                    if (ability.duration === 0) ability.active = false;
                }
            }
        }

        function spawnFood() {
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.random() * 1500 + 300;
            game.foods.push({
                x: player.x + Math.cos(angle) * dist,
                y: player.y + Math.sin(angle) * dist,
                radius: Math.random() * 3 + 2,
                color: `hsl(${Math.random() * 60 + 90}, 80%, 60%)`,
                pulse: Math.random() * Math.PI
            });
        }

        function spawnEnemy() {
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.random() * 1200 + 400;
            const massVariation = 0.5 + Math.random();
            const mass = Math.max(5, player.mass * massVariation);

            game.enemies.push({
                x: player.x + Math.cos(angle) * dist,
                y: player.y + Math.sin(angle) * dist,
                vx: 0,
                vy: 0,
                mass: mass,
                radius: Math.sqrt(mass) * 2.5,
                color: `hsl(${Math.random() * 40 + 340}, 80%, 55%)`,
                ai: Math.random() > 0.3 ? 'hunter' : 'wander'
            });
        }

        function updateFoods() {
            const myGravityRange = game.gravityRange * Math.sqrt(player.mass / 10) * player.gravityStrength;

            for (let i = game.foods.length - 1; i >= 0; i--) {
                const food = game.foods[i];
                const dx = player.x - food.x;
                const dy = player.y - food.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < myGravityRange && dist > 0) {
                    const pull = 0.05 * (player.mass / 10) * (myGravityRange - dist) / myGravityRange;
                    food.x += (dx / dist) * pull;
                    food.y += (dy / dist) * pull;
                }

                if (dist < player.radius + food.radius) {
                    const gain = food.radius * 0.6 * player.efficiency;
                    player.mass += gain;
                    game.dna += gain * 0.15;
                    createParticle(food.x, food.y, food.color, 4);
                    game.foods.splice(i, 1);
                }

                food.pulse += 0.08;
            }
        }

        function updateEnemies() {
            const myGravityRange = game.gravityRange * Math.sqrt(player.mass / 10) * player.gravityStrength;

            for (let i = game.enemies.length - 1; i >= 0; i--) {
                const enemy = game.enemies[i];
                const dx = player.x - enemy.x;
                const dy = player.y - enemy.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // èŒç‹è¡€ç»Ÿæ•ˆæœ - åœ¨å¼•åŠ›èŒƒå›´å†…è¢«å®šä½
                if (player.unlockedEvolutions.includes('fungus') && dist < myGravityRange && dist > 0) {
                    // æ•Œäººè¢«å®šä½ï¼Œæ— æ³•ç§»åŠ¨
                    enemy.vx = 0;
                    enemy.vy = 0;
                    
                    // æ·»åŠ å®šèº«ç‰¹æ•ˆ
                    if (game.gameTime % 10 === 0) {
                        createParticle(enemy.x, enemy.y, '#8B4513', 1);
                    }
                } else {
                    // æ­£å¸¸é‡åŠ›æ•ˆæœ
                    if (dist < myGravityRange && dist > 0 && player.mass > enemy.mass) {
                        const pull = 0.03 * (player.mass / enemy.mass) * (myGravityRange - dist) / myGravityRange;
                        enemy.vx += (dx / dist) * pull;
                        enemy.vy += (dy / dist) * pull;
                    }

                    if (enemy.ai === 'hunter' && dist < 500) {
                        if (enemy.mass > player.mass * 1.1) {
                            enemy.vx += (dx / dist) * 0.08;
                            enemy.vy += (dy / dist) * 0.08;
                        } else if (enemy.mass < player.mass * 0.9) {
                            enemy.vx -= (dx / dist) * 0.15;
                            enemy.vy -= (dy / dist) * 0.15;
                        }
                    } else {
                        enemy.vx += (Math.random() - 0.5) * 0.08;
                        enemy.vy += (Math.random() - 0.5) * 0.08;
                    }

                    if (player.unlockedEvolutions.includes('toxin') && dist < 250) {
                        enemy.vx *= 0.85;
                        enemy.vy *= 0.85;
                        if (game.gameTime % 10 === 0) createParticle(enemy.x, enemy.y, '#00ff00', 1);
                    }
                }

                enemy.vx *= 0.96;
                enemy.vy *= 0.96;
                enemy.x += enemy.vx;
                enemy.y += enemy.vy;

                if (dist < player.radius + enemy.radius && player.invincible === 0) {
                    if (player.mass > enemy.mass * 1.2 && !player.abilities.shield.active) {
                        const gain = enemy.mass * (player.unlockedEvolutions.includes('carnivore') ? 0.6 : 0.4);
                        player.mass += gain;
                        game.dna += gain * 0.8;
                        game.kills++;
                        createExplosion(enemy.x, enemy.y, enemy.color);
                        game.enemies.splice(i, 1);
                        showNotification(`åå™¬! +${Math.floor(gain)}`);
                    } else if (enemy.mass > player.mass * 1.2 && !player.abilities.shield.active) {
                        if (player.feignDeath.available && !player.feignDeath.used) {
                            triggerFeignDeath(enemy);
                        } else {
                            const defense = player.unlockedEvolutions.includes('membrane') ? 0.7 : 1;
                            const loss = player.mass * 0.3 * defense;
                            player.mass -= loss;

                            player.vx -= (dx / dist) * 10;
                            player.vy -= (dy / dist) * 10;

                            createExplosion(player.x, player.y, '#ff0000');

                            if (player.mass > 1) showNotification('è¢«å¼•åŠ›æ•è·! -' + Math.floor(loss));
                        }
                    }
                }
            }
        }

        function triggerFeignDeath(enemy) {
            player.feignDeath.used = true;
            player.invincible = 300;

            const dx = player.x - enemy.x;
            const dy = player.y - enemy.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            player.vx = (dx / dist) * 15;
            player.vy = (dy / dist) * 15;

            createExplosion(player.x, player.y, '#800080');

            for (let i = 0; i < 30; i++) {
                const angle = (Math.PI * 2 / 30) * i;
                game.particles.push({
                    x: player.x,
                    y: player.y,
                    vx: Math.cos(angle) * 8,
                    vy: Math.sin(angle) * 8,
                    life: 50,
                    maxLife: 50,
                    color: '#ff00ff',
                    size: Math.random() * 6 + 3
                });
            }

            document.getElementById('feign-death-indicator').classList.remove('active');
            document.getElementById('feign-death-indicator').textContent = 'ğŸ’€ å‡æ­»å·²ä½¿ç”¨';
            document.getElementById('feign-death-indicator').style.background = 'rgba(128,0,128,0.3)';
            document.getElementById('feign-death-indicator').style.display = 'block';

            showNotification('ğŸ’€ å‡æ­»è§¦å‘! å…ç–«è‡´å‘½ä¼¤å®³!');

            setTimeout(() => {
                if (!player.isDead) {
                    document.getElementById('feign-death-indicator').style.display = 'none';
                }
            }, 5000);
        }

        function updateParticles() {
            for (let i = game.particles.length - 1; i >= 0; i--) {
                const p = game.particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                p.alpha = p.life / p.maxLife;
                if (p.life <= 0) game.particles.splice(i, 1);
            }
        }

        function createParticle(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                game.particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 5,
                    vy: (Math.random() - 0.5) * 5,
                    life: 25,
                    maxLife: 25,
                    color: color,
                    size: Math.random() * 3 + 1
                });
            }
        }

        function createExplosion(x, y, color) {
            for (let i = 0; i < 15; i++) {
                const angle = (Math.PI * 2 / 15) * i;
                game.particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * 6,
                    vy: Math.sin(angle) * 6,
                    life: 35,
                    maxLife: 35,
                    color: color,
                    size: Math.random() * 5 + 2
                });
            }
        }

        function checkEvolution() {
            const stages = ['åŸå§‹ç»†èƒ', 'åŸæ ¸ç”Ÿç‰©', 'çœŸæ ¸ç”Ÿç‰©', 'å¤šç»†èƒä½“', 'æ™ºæ…§ç”Ÿå‘½'];
            let newStage = 0;
            if (player.mass > 100) newStage = 1;
            if (player.mass > 600) newStage = 2;
            if (player.mass > 2500) newStage = 3;
            if (player.mass > 10000) newStage = 4;

            if (newStage > game.evolutionStage) {
                game.evolutionStage = newStage;
                showNotification(`ğŸ§¬ è¿›åŒ–: ${stages[newStage]}!`);
                document.getElementById('stageDisplay').textContent = stages[newStage];

                // è¾¾åˆ°æ™ºæ…§ç”Ÿå‘½æ—¶æ˜¾ç¤ºèƒœåˆ©ç•Œé¢
                if (newStage === 4 && !game.victoryShown) {
                    setTimeout(() => showVictory(), 1000);
                }
            }
        }

        function die() {
            player.isDead = true;
            game.running = false;

            const survivalTime = Math.floor((Date.now() - game.startTime) / 1000);

            document.getElementById('final-mass').textContent = Math.floor(player.mass);
            document.getElementById('final-dna').textContent = Math.floor(game.dna);
            document.getElementById('final-time').textContent = survivalTime + 's';
            document.getElementById('final-kills').textContent = game.kills;

            document.getElementById('death-screen').classList.add('show');
            document.getElementById('health-warning').classList.remove('show');
            document.getElementById('feign-death-indicator').classList.remove('active');
            document.getElementById('quantum-ready').classList.remove('active');
            document.getElementById('super-mode-indicator').classList.remove('active');
        }

        // æ¸²æŸ“
        function render() {
            ctx.fillStyle = 'rgba(10, 10, 26, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (player.isDead) return;

            ctx.save();

            ctx.translate(game.width / 2, game.height / 2);
            ctx.scale(game.camera.zoom, game.camera.zoom);
            ctx.translate(-game.camera.x, -game.camera.y);

            drawGrid();

            const myGravityRange = game.gravityRange * Math.sqrt(player.mass / 10) * player.gravityStrength;
            ctx.beginPath();
            ctx.arc(player.x, player.y, myGravityRange, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 0, 0.03)';
            ctx.fill();
            ctx.strokeStyle = 'rgba(255, 255, 0, 0.1)';
            ctx.lineWidth = 2 / game.camera.zoom;
            ctx.setLineDash([10 / game.camera.zoom, 10 / game.camera.zoom]);
            ctx.stroke();
            ctx.setLineDash([]);

            // èŒç‹è¡€ç»Ÿå…‰ç¯ç‰¹æ•ˆ
            if (player.unlockedEvolutions.includes('fungus')) {
                ctx.beginPath();
                ctx.arc(player.x, player.y, myGravityRange, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(139, 69, 19, 0.3)';
                ctx.lineWidth = 3 / game.camera.zoom;
                ctx.setLineDash([5 / game.camera.zoom, 10 / game.camera.zoom]);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // æ°”æ¯è¿½è¸ªç›®æ ‡æŒ‡ç¤ºçº¿
            if (player.abilities.track.active && player.abilities.track.target) {
                const target = player.abilities.track.target;
                ctx.beginPath();
                ctx.moveTo(player.x, player.y);
                ctx.lineTo(target.x, target.y);
                ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
                ctx.lineWidth = 3 / game.camera.zoom;
                ctx.setLineDash([5 / game.camera.zoom, 5 / game.camera.zoom]);
                ctx.stroke();
                ctx.setLineDash([]);

                // ç›®æ ‡æ ‡è®°
                ctx.beginPath();
                ctx.arc(target.x, target.y, target.radius + 10, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(0, 255, 0, 0.8)';
                ctx.lineWidth = 2 / game.camera.zoom;
                ctx.stroke();
            }

            game.foods.forEach(food => {
                const pulse = Math.sin(food.pulse) * 0.3 + 1;
                ctx.beginPath();
                ctx.arc(food.x, food.y, food.radius * pulse, 0, Math.PI * 2);
                ctx.fillStyle = food.color;
                ctx.shadowBlur = 15;
                ctx.shadowColor = food.color;
                ctx.fill();
                ctx.shadowBlur = 0;
            });

            game.enemies.forEach(enemy => {
                const dx = enemy.x - player.x;
                const dy = enemy.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const inGravity = dist < myGravityRange && player.mass > enemy.mass;

                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);

                if (inGravity) {
                    const grad = ctx.createRadialGradient(
                        player.x, player.y, 0,
                        enemy.x, enemy.y, enemy.radius * 2
                    );
                    grad.addColorStop(0, 'rgba(255, 255, 0, 0.3)');
                    grad.addColorStop(1, enemy.color);
                    ctx.fillStyle = grad;
                } else {
                    const grad = ctx.createRadialGradient(
                        enemy.x - enemy.radius * 0.3, enemy.y - enemy.radius * 0.3, 0,
                        enemy.x, enemy.y, enemy.radius
                    );
                    grad.addColorStop(0, '#ff8888');
                    grad.addColorStop(1, enemy.color);
                    ctx.fillStyle = grad;
                }

                ctx.fill();

                if (inGravity && game.gameTime % 10 < 5) {
                    ctx.beginPath();
                    ctx.moveTo(player.x, player.y);
                    ctx.lineTo(enemy.x, enemy.y);
                    ctx.strokeStyle = 'rgba(255, 255, 0, 0.2)';
                    ctx.lineWidth = 1 / game.camera.zoom;
                    ctx.stroke();
                }

                if (enemy.mass > player.mass) {
                    ctx.fillStyle = '#ff0000';
                    ctx.font = `bold ${16 / game.camera.zoom}px Arial`;
                    ctx.fillText('!', enemy.x - 4, enemy.y - enemy.radius - 8);
                }
            });

            player.trail.forEach((t, i) => {
                ctx.beginPath();
                ctx.arc(t.x, t.y, player.radius * (i / player.trail.length) * 0.4, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(0, 255, 136, ${t.alpha * 0.3})`;
                ctx.fill();
            });

            // ç©å®¶ - è¶…çº§æ¨¡å¼ä¸‹æ”¹å˜å¤–è§‚
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);

            if (player.superMode) {
                // è¶…çº§æ¨¡å¼å¤–è§‚
                const grad = ctx.createRadialGradient(
                    player.x - player.radius * 0.3, player.y - player.radius * 0.3, 0,
                    player.x, player.y, player.radius
                );
                grad.addColorStop(0, '#ff88ff');
                grad.addColorStop(0.5, '#ff00ff');
                grad.addColorStop(1, '#800080');
                ctx.fillStyle = grad;
                ctx.shadowBlur = 30;
                ctx.shadowColor = '#ff00ff';
            } else if (player.unlockedEvolutions.includes('fungus')) {
                // èŒç‹è¡€ç»Ÿå¤–è§‚
                const grad = ctx.createRadialGradient(
                    player.x - player.radius * 0.3, player.y - player.radius * 0.3, 0,
                    player.x, player.y, player.radius
                );
                grad.addColorStop(0, '#D2691E');
                grad.addColorStop(0.5, '#8B4513');
                grad.addColorStop(1, '#654321');
                ctx.fillStyle = grad;
                ctx.shadowBlur = 25;
                ctx.shadowColor = '#8B4513';
            } else {
                const grad = ctx.createRadialGradient(
                    player.x - player.radius * 0.3, player.y - player.radius * 0.3, 0,
                    player.x, player.y, player.radius
                );
                grad.addColorStop(0, '#aaffcc');
                grad.addColorStop(0.5, '#00ff88');
                grad.addColorStop(1, '#006644');
                ctx.fillStyle = grad;
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#00ff88';
            }

            ctx.fill();
            ctx.shadowBlur = 0;

            if (player.invincible > 0 && Math.floor(game.gameTime / 5) % 2 === 0) {
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.radius + 5, 0, Math.PI * 2);
                ctx.strokeStyle = player.superMode ? 'rgba(255, 0, 255, 0.8)' : 'rgba(255, 255, 255, 0.8)';
                ctx.lineWidth = 3 / game.camera.zoom;
                ctx.stroke();
            }

            if (player.abilities.shield.active) {
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.radius + 12, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(0, 200, 255, ${0.6 + Math.sin(game.gameTime * 0.3) * 0.3})`;
                ctx.lineWidth = 4 / game.camera.zoom;
                ctx.stroke();
            }

            ctx.beginPath();
            ctx.arc(player.x, player.y, player.radius * 0.25, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fill();

            game.particles.forEach(p => {
                ctx.globalAlpha = p.alpha;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fillStyle = p.color;
                ctx.fill();
            });
            ctx.globalAlpha = 1;

            ctx.restore();

            updateUI();
        }

        function drawGrid() {
            const gridSize = 150;
            const offsetX = Math.floor(game.camera.x / gridSize) * gridSize;
            const offsetY = Math.floor(game.camera.y / gridSize) * gridSize;

            ctx.strokeStyle = 'rgba(0, 255, 136, 0.04)';
            ctx.lineWidth = 1 / game.camera.zoom;

            const viewSize = Math.max(game.width, game.height) / game.camera.zoom;

            for (let x = -viewSize; x < viewSize; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x + offsetX, -viewSize);
                ctx.lineTo(x + offsetX, viewSize);
                ctx.stroke();
            }
            for (let y = -viewSize; y < viewSize; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(-viewSize, y + offsetY);
                ctx.lineTo(viewSize, y + offsetY);
                ctx.stroke();
            }
        }

        function renderMinimap() {
            if (!game.running) {
                requestAnimationFrame(renderMinimap);
                return;
            }

            minimapCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            minimapCtx.fillRect(0, 0, 100, 100);

            const scale = 0.015;
            const centerX = 50;
            const centerY = 50;

            minimapCtx.strokeStyle = 'rgba(0, 255, 136, 0.2)';
            minimapCtx.lineWidth = 1;
            minimapCtx.beginPath();
            minimapCtx.arc(centerX, centerY, 48, 0, Math.PI * 2);
            minimapCtx.stroke();

            minimapCtx.fillStyle = '#00ff88';
            game.foods.forEach(food => {
                const dx = (food.x - player.x) * scale;
                const dy = (food.y - player.y) * scale;
                if (Math.abs(dx) < 48 && Math.abs(dy) < 48) {
                    minimapCtx.fillRect(centerX + dx, centerY + dy, 2, 2);
                }
            });

            game.enemies.forEach(enemy => {
                const dx = (enemy.x - player.x) * scale;
                const dy = (enemy.y - player.y) * scale;
                if (Math.abs(dx) < 48 && Math.abs(dy) < 48) {
                    const size = Math.max(2, enemy.radius * scale * 0.5);
                    minimapCtx.beginPath();
                    minimapCtx.arc(centerX + dx, centerY + dy, size, 0, Math.PI * 2);
                    if (enemy.mass > player.mass) {
                        minimapCtx.fillStyle = '#ff0000';
                    } else {
                        minimapCtx.fillStyle = '#ffff00';
                    }
                    minimapCtx.fill();
                }
            });

            minimapCtx.fillStyle = '#ffffff';
            minimapCtx.beginPath();
            minimapCtx.arc(centerX, centerY, 3, 0, Math.PI * 2);
            minimapCtx.fill();

            const viewRadius = (game.baseViewRange * player.viewMultiplier * Math.pow(player.mass / 10, 0.4)) * scale;
            minimapCtx.strokeStyle = 'rgba(0, 255, 136, 0.5)';
            minimapCtx.lineWidth = 1;
            minimapCtx.beginPath();
            minimapCtx.arc(centerX, centerY, Math.min(48, viewRadius), 0, Math.PI * 2);
            minimapCtx.stroke();

            requestAnimationFrame(renderMinimap);
        }

        function updateUI() {
            document.getElementById('massDisplay').textContent = Math.floor(player.mass);
            document.getElementById('dnaDisplay').textContent = Math.floor(game.dna);

            let nextThreshold = 100;
            if (player.mass > 100) nextThreshold = 600;
            if (player.mass > 600) nextThreshold = 2500;
            if (player.mass > 2500) nextThreshold = 10000;

            let prevThreshold = 0;
            if (player.mass > 100) prevThreshold = 100;
            if (player.mass > 600) prevThreshold = 600;
            if (player.mass > 2500) prevThreshold = 2500;
            if (player.mass > 10000) prevThreshold = 10000;

            const progress = (player.mass - prevThreshold) / (nextThreshold - prevThreshold) * 100;
            document.getElementById('progress-fill').style.width = Math.min(100, progress) + '%';

            if (game.gameTime % 60 === 0) updateEvolutionUI();
        }

        function showNotification(text) {
            const notif = document.getElementById('notification');
            notif.textContent = text;
            notif.classList.add('show');
            setTimeout(() => notif.classList.remove('show'), 2000);
        }

        // æ¸¸æˆå¾ªç¯
        function gameLoop() {
            if (!game.running) return;
            update();
            render();
            requestAnimationFrame(gameLoop);
        }

        // å¯åŠ¨
        init();
    </script>
</body>
</html>
